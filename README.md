# Catan OOP Game
Authors - Krupa, Hadeya, Liz

Introduction
<br>
In this document, we present an in-depth analysis of our game "Constructors," which is inspired by the popular board game Catan. This game showcases the application of various design patterns and OOP principles. Throughout this report, we will provide a comprehensive overview of the project, detailing the overall structure, the UML class model, and the design techniques used to address the various challenges encountered during the development process. Additionally, we will discuss how our design supports adaptability and resilience to changes in the program specification.

Overview
<br>
The Implementation follows the format of the Model View Controller Design pattern. The Model class stores the application's main components and mediates communication between the Board and Player. It stores the data of each Player (an array of 4 players on the stack) as well as the Board (also on the stack). Model is then updated through function calls from the Controller class. The Controller class is responsible for handling user input and control flow, while the View represents the user interface and is responsible for displaying data to the user. It retrieves data from the Model and renders it to the user.

Our program runs by first calling the controller class. It uses the built in ctor resulting in all fields except Model and View being set. In this Controller class, we had a general function that outlined the different phases of the game:
Controller::createController()
Controller::beginnningOfGame()
Controller::beginningOfTurn()
Controller::DuringTurn()

In the Controller::general(), we first call createController() which deals with all logic for reading in command line arguments and determines whether we load the board, load a game, or randomise a board. After that, setModel is called, which deals with extracting the necessary data for creating a Model and View. It deals with randomising a board/reading in information and placing data accordingly for the Model ctor. All throughout, the program is also checking for invalid input (which uses global variable invalidInput). The functions then return 0 to Controller::general() indicating success or the constant invalidInput to signify ending the program which is then dealt with accordingly by returning the error variable to main. 

From then on, every function call from within Controller::general() returns a state: 0 for regular, eof for end of file, eofNoSave for end of file + save() function has already been called, and gameWon for a player having 10 or more building points.

Ctors
<br>
There are 2 versions of a Model ctor - one is used for loading a game and another for loading a board. When any Model ctor is created, it receives necessary information to create a Board and Players. In the Board ctor, there are also 2 versions. One is used for loading in a game - it calls the other Board ctor (the general one) which creates the Tiles and adds the resources (in body of ctor) and then the first ctor adds the geese accordingly in its own body. The general board ctor also modifies all the tiles and their vertices/edges by setting the adjacency relationships (in body of ctor). It gives each edge and vertex a list of all edges and vertices it’s adjacent to which is set using a public setter function (more on invariants of this part in the design section). These are what gets used to check if the player can place a road or edge. When creating the Board Constructor, we first create all the vertices and edges so we  have their memory addresses to give to the Tile ctor. In the case of just loading in a board, only the general Board ctor is called, which also creates the Tiles and resources but also deals with the geese (dictated by a boolean which tells the program that it’s not being used to load in a game). Then the Tile ctor gets pointers to the vertices and edges it holds and all other necessary information for its fields. The player also has 2 ctors - one for when a game would be loaded in and one for a fresh game. After model is created, Controller then gives view a pointer to model.

Control Flow of Game
<br>
Then in the general function, we move on to the beginning of the game. From now on, every function call from within Controller::general() returns a state (0 for regular, eof for end of file, eofNoSave for eof + save() function has already been called, or gameWon for a player having 10 or more building points). General() then deals with this accordingly by calling save(), and/or returning eof to main, continuing the game as needed. 
Moving on, if we didn’t load in a game, we then call beginningOfGame(). This function deals with placing the 2 basements for each Player. Then if we did load in a game, the function checks if a player has already gained 10 or more points: if they have then the following section is skipped. This consists of beginningOfTurn() and duringTurn(). beginningOfTurn() deals with getting input from the user for the dice type, rolling the dice, and updating player’s information based on the dice rolled. duringTurn() gets commands from the user until next is entered or if a player gained 10 or more building points. 

Winning Game
<br>
Once the game has been won, in Controller::general(), the player is prompted to start a new game or stop. This is the only time where if eof is encountered, the state of the game is not saved. If a player wants to start a new game, the restart() function just randomises a new board and creates a new model and view using the built-in move assignment operator for a unique_ptr. 

Geese
<br>
Our geese function in the Controller class performs all of the necessary tasks when a 7 is rolled. All prompts are printed in the Controller class, and when the input is read in from the client, it is passed to smaller methods within the Model class. The model class first loops through the players and returns a vector of all players that have lost half of their resources. This data is printed in the Controller classes geese method. We used the logic presented in the shuffle.cc file, along with an additional class template called “std::uniform_int_distribution<int>”, to randomly select which resources would be lost from the players to make sure that every resource had an equal probability of being removed. The geese is placed on the new tile, and the previous tiles isGeese is set to false, while the new tiles is set to true. Finally, we generated a list of players the current player could steal from, based on their resourceTotal, their colour, and whether they have residences on the geese tile. The client is then prompted to choose a player to steal from, and the same logic is used to randomly select a resource from the indicated player. 


Trade
<br>
The trade function in the controller class follows a very similar ideology, where we check that the trade can be made, and then add and remove the trade resources from the two players involved in the trade. 

Updating Resources Gained
<br>
If the dice rolled was not a 7, we update resources gained for each player by calling Model::diceRolledUpdate which returns a vector of length 4 where each index stores a map of resources and integers representing the resources gained for that player. We then loop through each player and print their resources. In diceRolledUpdate(), for each player, we get their occupied tiles. Then for each tile in occupiedTiles, we call Board::getResoc() which calls Tile::evalResoc() which then returns a pair of a Resource and an integer representing the amount of resources gained for that tile. These get added to the array of all resources gained (only if amount of resources gained > 0) that will be returned and are also passed to updateResoc map which adds the gained resources for the particular player while also updating resocTotal. evalResoc checks for the park tile (in that case, it returns nothing) and then calls getResidenceAmount for each vertex which just returns the Residence.

Placing a Basement
<br>
There are 2 cases. The first case is at the beginning of the game when players place their 2 basements. Controller::buildDefaultBasements() is called which. It deals with getting user input (including any invalid input where if not eof, the program continues trying to read in from the same player) and determining if the user can place the basement there or not. This is its implementation, it calls Model::placeBasement() which returns true or false. If true is returned it means that the basement was placed and false otherwise. The second case is when placing a basement using the build-res command. in which Controller::buildRes() is called then . It first checks if the player has enough resources to build a basement by calling Model::hasEnoughResoc() which returns true or false by calling Player::hasEnough Resoc on the player whose turn it is. Then Model::placeBasement() is also called. This function then calls Board::placeBasement(), Tiles::placeBasement(), and Vertex::placeBasement(). Starting at Vertex::placeBasement(), this function checks if we have found the vertex the user wants to place a basement on. If that's not the case, then we just return; so nothing gets thrown up the call chain. If we have found the vertex, we do all the necessary checks for that vertex (is it occupied) and other vertices by looping through its adjacent vertices (are they occupied). Then if this function was called by Controller::buildDefaultBasements() (determined through a variable), we don’t check the adjacent edges. If it was called by Controller::buildRes() we check that the player has an adjacent edge occupied as we loop through adjEdges. If we pass all necessary requirements the residence and player type is added to the vertex and true is thrown, otherwise false is thrown. In Tiles::placeBasement(), we catch and throw the boolean that was thrown by the Vertex::placeBasement() function. While we could have omitted the try-catch block, we decided to explicitly show that there was something being thrown through this function in order to be more careful. In Board::placeBasement(), if we catch true, we then throw the tile number that the try-catch block was executed from and if its false, we don’t throw anything and just end the function call. In Model::placeBasement(), if we catch the tileNum (int), we add the buildingPoints by calling a function in player, and then call a function in Model to find all other tiles containing the vertex we placed a basement on and add them to occupiedTiles in the Player class. We then return true. If nothing was caught, we return false. Then in buildRes and buildDefaultBasements in Controller outputs the necessary information based on the return statement. 

Placing A Road
<br>
The same logic is applied here as placing a basement. The only difference is that the functions have different names and their rules/functionality are a bit different. For example, we don’t add building points if a road is placed and Edge::placeRoad() function has different criteria for placing a road. In the placeRoad() function in the Edge class, we also loop through vertices and edges but we also loop through the vertices of the adjacent edges as well to prevent building a road through a residence of a different player.

Improving a Residence
<br>
The placeNonBasement() function works in a similar manner. The sequence and layout of the function call is the same. The only difference is that in Vertex:placeNonBasement(), after checking all the necessary criteria, if it was met, we either throw a pair of the Residence type that was improved and true for the residence being improved of the residence that was at the vertex that was not improved and false to show that no new residence was placed. In Tile:placeNonBasement() andBoard::placeNonBasement(), we rethrow the pair until we reach Model. Then, Model also computes similarly to the placeBasement function, and returns the pair. In Controller::improveRes, we then check for if the player has enough resources first (if the residence type was not Residence::NONE) and then output the necessary code. We did it this way so that having the correct number of resources would take priority in terms of outputting the validity of placing residences and roads.

printBoard Function
<br>
The printBoard function in the View class utilises the setw() function from the iomanip library to maintain symmetric padding regardless of the length of the tile’s contents. It also uses several helper functions to print different components of the board, such as the bars, tile labels, edges, and vertices. Since all the tiles are stored in an array, the function iterates through each tile to obtain its associated resource, value, and number to print. This function was part of the View class as printing the board is part of the user interface and displaying the data of the board. 

Comparing DD1 Layout Vs Current Layout
<br>
While there is a similar layout with the relationship between the Tiles, Board, and Components, the layout we originally had planned was extremely different from what we have now. We intended to use the observer pattern where the Players would be updated based on changes to the board. Having done our project now, we see that the observer pattern would have made things a lot more complicated than needed as there would need to be much more function calls to communicate data between the Players and Board. Additionally, there would be low cohesion since we originally thought all classes should be responsible for printing to standard output and printing would be shared by various classes (board, tile, and component). Moreover the original design did not even account for the control flow of the game. If we had stuck with our original plan, we probably would have had a huge main function, which would have been a really poor design and would have not been easy to reset and reload the game once it was over.

UML 
<br>
https://lucid.app/lucidchart/7454e148-4251-4686-8a1b-a2f41c28afa9/edit?invitationId=inv_6e2c8d98-7914-475c-af1c-a6075ebb96c4

Design
<br>
In order to create the program, we utilised the MVC architecture design pattern so that each class would be responsible for a particular part of the program. For example, the Controller is responsible for the printing and control flow of the game, the View is for printing the layout of the board, and Model to store all the data of the game. In the Controller class itself, we utilised many functions that broke up the control of the game. For example, we had beginningOfGame() and beginningOfTurn() and other functions to signify different stages in the game. The controller class would call functions of View (mainly printBoard()) to print the board to the screen and it would also call functions from Model to get necessary information from Board and Player classes and act accordingly. 
We also designed the game with low coupling and high cohesion in mind. Everytime, Controller would need to modify Board or Player, or get information from them, there would be a sequence of calls where e.g. Model would call a Board function which would call a Tile function which would call a Component function to modify its own fields and then pass necessary information to upper classes. There are a lot of functions that deal with letting outside classes work with the data of the class without giving them access to their fields (eg updateResocMap() or addBuildingPoints()). All fields in every class are private and can only be accessed through public functions. This route is taken when constructing instances of the objects. For example, when a Model is created, the Model would create a Board and a Player and then the Board would create the 19 Tiles… and so on with Component.
Additionally, each class has its own particular purpose in the game. For example, Model maintains communication between Player and Board and acts as an interface for the classes. Model contains many functions to access Board and Player accordingly and deals with the transfer of communication between the 2 classes which then computes necessary actions as needed by the Controller. View only contains print functions for printing out the contents of the board. Board contains functions to place residences, roads, or to place geese, etc… Controller only contains functions that deal with control flow or commands taken from standard input. 
Additionally, each class stores information specific to their purpose. For example, “turn” is stored in Controller, as Controller is responsible for the flow of the game. Additionally, Tile stores all information that a tile needs - e.g. its tile value, tile number, whether it's a geese or not, and the edges and vertices that make up the tile. 
*While we don’t really like that the Board stores an array of edges and vertices as that should only be stored in  Tile, this addition was necessary and we  did not use these arrays to directly access the vertices and edges anywhere in the program. We only access tiles and vertices through the Tile class in order to maintain encapsulation. These arrays are only used to create the addresses of vertices and edges before the Tiles are constructed in the Board class. We thought everything should be created as directly as possible using the MIL in the constructors. To specify, we needed to create the edges and vertices before we created the tiles so that each vertex and edge would be able to store the addresses of its adjacent vertices and edges and access them to prevent looping through the entire board.*
There were other designs we came up with in order to cut down on runtime. For example, each player stores a vector of numbers that represent tiles that have residences or roads owned by the Player. This way when we need information from the board for each player, we don’t need to search all the tiles. Additionally when adding multiple tiles for a placement of 1 edge or tile, we created a vector of distinct tiles and edges to not have to loop through every tile and check if the residence we built was on that tile. And we also took into account that there is a maximum of 2 tiles sharing an edge and a maximum of 3 tiles sharing a vertex to reduce runtime - we would stop looping if we got the max. 
Moreover, there were a lot of enumerations and global const variables used to get rid of magic numbers in our code. For example the number of tiles was stored in tilesAmount,  the number of players was stored in playerAmount, and certain states e.g. EOF or invalid input were represented by a variable as well. Enumerations were also used to group data and improve communication. For example, the 3rd index in the players array in class Model represented the colour Orange (in the enum O = 3) and Residence H had 2 building points (in the enum H = 2). 
Additionally, since a lot of information was given in advance (e.g. number of players or tiles), we choose to create the majority of our data on the stack - e.g. Players, Board, Controller, vertices, edges. This way, the possibility of memory leaks would be reduced. 
Furthermore, we also used other forms of design. We only added the adjacent vertices and edges to the first numbered tile in the board and not the ones following it. This made it so we didn’t need to add copies of the relationships for every single vertex and edge in the board since we decided we would loop from tiles 1-19 and the first tile we encounter storing the vertex or edge we want would have the adjacency lists. Additionally this also helped cut down on runtime, since all the logic would be done at the first tile we found. So in the case that adding the residence or road is valid, we know all other tiles sharing that vertex/edge can only occur in front of that tile, which makes it so we don’t have to start at the beginning of the board and look for all the tiles sharing the vertex/edge.
Resilience to Change
	Due to the fact that we used the Architecture Model-View-Controller pattern to organize the structure of our code, we are now able to easily implement a graphical interface, or show our data in different ways. Within the View class, we could create several decorators to display our data in different forms. For example, we could have a decorator that displays a colour-coded board, or a decorator that visually shows the resource production from a tile.  
Again, since we made use of the MVC design pattern, we are able to reuse our code with ease. One way we can do this is by adding more players, and this would not cause a change in the interface. Since our model class has an array of players, we would not have to add any new code to deal with this. 
In terms of our Tile class, we could add more fields to it, to allow for the implementation of extra features and to store more specific data overall. For example, we could add a special tile, such that if a user rolled that number, they would have the ability to perform a special random action, similar to how the “chance” and “community chest” tiles function in Monopoly. This would have made the game a lot more interesting and fun for the users.  
While writing our code, we made the decision to keep many important methods belonging to different classes public, and this allows us to easily be able to reuse our code when implementing new changes. Particularly, many of the public methods that we have perform basic tasks such as modifying and accessing certain fields, and therefore, it would not be difficult to reuse these methods. 
Our decision to use the MVC design pattern has contributed significantly to our ability to reuse our code while still implementing new changes. One way we could do this is by adding a new control flow. By doing so, all we would need to do is modify the Controller class, since it is the only class that deals with the current control flow. All of our other classes would remain the same.
Another change we could easily implement is to add more commands to the Controller class. We have already dealt with the several commands that were outlined in the project specifications, and to add a few more would not be very difficult. In essence, we would just need to add in the command name in the existing while loop and add a method in the Controller class to perform a task related to that particular command. 
Our team stayed true to the object-oriented aspect of our project, and so we have ensured that each function and class we wrote carries out a specific task. Thus, there are no significant dependencies or links between random methods between classes, which allows for us to be easily able to modify any method in our program. 
Due to modularization, with a lot of new changes, we would only have to alter one class most of the time, since the classes are loosely coupled. This is the case since the classes only communicate with each other using public functions, and we have decided not to make any classes friends.
Furthermore, if we wanted to change the format of the save function, we would only have to alter how we add the code to the file stream that is currently being used within this function. Otherwise, all the necessary functions to get data from the board and the players are the same. 
In terms of adding more residences or resources, it would be quite easy to do so since all we would have to do is alter the enumeration, and most functions dynamically use these enumerations.
Lastly, if we wanted to add a different type of component, it would also be easy to do so, since there is a common interface for a component, which currently extends to the Vertex and Edge classes.


Answers to Questions 
<br>
1. You have to implement the ability to choose between randomly setting up the resources of the board and reading the resources used from a file at runtime. What design pattern could you use to implement this feature? Did you use this design pattern? Why or why not? 
	
The initial answer to this question was to use the factory method pattern to implement this feature. This was the case because we would not know how the board would be set up until runtime. Also, we mentioned in DD1 that this would cause us to not be able to hard code the board in our program, since the board could be randomized or loaded from a file provided by the client. We mentioned that since this would be the case, we would create two different classes to either load the board with a file, or to load the board with a randomized algorithm.   
However, after writing the majority of the constructor game and getting to the point where it was time to start implementing this feature, we did not go through with using the factory method design pattern. This was primarily due to a lack of logic present in using this design pattern.
Instead, we used the Architecture Model-View-Controller pattern instead. In the controller class, we created several methods to run the game. Within these functions, we created a method in the Controller class called setModel(), which initializes the model with certain Boolean variables, such as canRandomize and foundRandomize. Instead of dividing the loading of the board into several classes, we dealt with the different cases within the controller class, using a series of methods and conditional statements to determine how the board will be created. For example, if the client failed to specify the commands “-load” and “-board,” then we knew to load the board from the default file. If they did specify one of these commands, we either randomize the board, or use their provided file to load the board.

2. You must be able to switch between loaded and fair dice at run-time. What design pattern could you use to implement this feature? Did you use this design pattern? Why or why not? 
You could use the factory design pattern where depending on what the user enters “load” or “fair”, you would either create a loaded or fair die. This would be a good implementation since this is determined at runtime and this design would respond well to change if e.g. you wanted to add a third type of dice or each player wanted to have multiple dice. However, we didn’t end up using the design pattern since if we kept the implementation of the factory method pattern, we would have to delete old object instances and create new ones every time the user would decide to switch to a different dice type. Additionally, the functionality of each newly created object might not even be used e.g. the user can switch many times between roll and fair, and then the functionality of the dice object would only be used for the last dice type declared). Instead each player just had a dice object which would just store the name of the particular dice type so that we wouldn’t have to create a new object every time and we could just modify the same object instance.

3. We have defined the game of Constructor to have a specific board layout and size. Suppose we wanted to have different game modes (e.g. hexagonal tiles, a graphical display, different sized board for a different number of players). What design pattern would you consider using for all of these ideas?
You could implement a Factory method pattern. Depending on which game mode the user wants, an object of a certain type would be created which would dictate what size board gets created, how many players are going to be played in the game… etc. There would be predefined subclasses representing the specific modes you want and an abstract parent class. You could then even change up the different game modes in the same run of the program, just by deleting the old object (as it would be allocated on the heap) and allocating a new object of a different subclass. Additionally, this type of implementation would make the program pretty easy to alter. You would be able to add new implementations with practically no changes to the user interface.

6. Suppose we wanted to add a feature to change the tiles’ production once the game has begun. For example, being able to improve a tile so that multiple types of resources can be obtained from the tile, or reduce the quantity of resources produced by the tile over time. What design pattern(s) could you use to facilitate this ability? 
The design patterns that could be used to facilitate this ability are both the observer and decorator patterns. Implementing these two patterns in a way where they work together can allow for the client to make these changes to the objects at runtime. For example, the observer pattern would be used to notify each of the tile objects belonging to the board of the change, and the decorator pattern would be used to implement the different sorts of changes that could be made to the tiles. Similar to creating the studio and canvas in assignment 3 within questions 3 and 4, this concept would use a similar methodology. These two design patterns would work together because of the fact that there are different types of changes that could be made to each of the tiles, and there are multiple tiles belonging to a board. The answer to this question did not change from DD1 to DD2.

7. Did you use any exceptions in your project? If so, where did you use them and why? If not, give an example of a place that it would make sense to use exceptions in your project and explain why you didn’t use them. 
Yes we used exceptions. They were partly used for catching errors (e.g. setting the seed when using the soi built-in function). Additionally they were mainly used when building residences and roads. Here, we used the try catch blocks to throw bools, integers, and Residences. We used exceptions in these functions because sometimes you would need a function to return something and sometimes you wouldn’t: throwing and catching works very well for this. Ex: in the placing residence and roads functions, we would need to loop through the tiles to find the vertex/edge we want and then determine if we can place the road/residence on there. Some tiles wouldn’t even have the vertex/edge we want to find, so you wouldn’t need anything from those function calls (aka was a residence placed or not). Therefore it would be cleaner to loop through all the tiles and return information pertaining to the status of a placed road/vertex only if the vertex/edge was found on the tile. Looking back, it would have also been better to use exceptions for invalid input when reading in (specifically when eof would be encountered). We wrote it so that we would return if we found eof or not in each function call in Controller, but throwing and catching would have been a cleaner and more elegant solution.

Extra Credit Features 
To begin, we ensured that there were no new’s and delete’s present in our code. This part was tricky to implement since it would have been easy to reset the game, simply by deleting the pointer to the board to get rid of all the settlements and roads built and creating a new one, so that the constructor could initialise all fields to the standard state of the board before the players start. It would have been easier this way to reset all the players and their status as well. Regardless, we managed to utilise smart pointers and created a reset function to take care of all issues, to reset the game properly. 
Also, since we do not use new and delete in the code, we have no memory leaks! 

Final Questions

1. What lessons did this project teach you about developing software in teams? If you worked alone, what lessons did you learn about writing large programs? 
This project taught us many different things about developing software in teams. To begin, we learned very quickly that the initial plan we had created was no longer going to work. We learned specifically that no amount of planning will prepare you for the flaws in your logic you will encounter when you actually begin to code. As well, we had to significantly modify our initial plan as we continued to code.
Another crucial thing we learned is that communication is extremely important and necessary. More specifically, we learned that frequent in-person meetings are an effective way to coordinate individual responsibilities within the project and allow all team members to stay on the same page. Our team would meet with each other almost every other day and so we were able to communicate openly about all aspects of the project, such as our desired grade and our desired level of completion of the game.
We also learned that coming up with solutions to problems becomes a more fulfilling task, due to all of the different levels of backgrounds each team member brings to the group. It doesn't feel like a dead end when the team is faced with a challenge. This lesson learned was one of the more eye-opening lessons because it really shed light on the benefits of working within a team. 

2. What would you have done differently if you had the chance to start over?

First and foremost, our team hesitated when it came time to use exceptions. While we did end up using exceptions in our code, we wish that we would have used them more than we did, specifically when dealing with EOF. By doing so, we would have been able to code more efficiently, as well as submit cleaner code, and we would have been able to separate all parts of the code that pertained to error-handling. 
When creating the Board constructor, we first had to initialize all of the tiles with their respective vertices and edges in the member initialization list. This required a bit of hardcoding but it was not as big of a task as hardcoding the adjacency relationships for each and every vertex and edge. In the project specifications, we were warned about this and we were encouraged to either hardcode these relationships, or come up with an algorithm to do that for us. We chose to hardcode the relationships and after completing the project, we can say with confidence that we wished we would have created an algorithm for it instead. This portion of the code required almost 1000 lines, it was very tedious to complete, and it was a very error-prone task. 
Just as we mentioned that we wish we would have done less hardcoding with the adjacency relationships of the vertices and edges, we also wish that we would have done less hardcoding in general. There were methods in the different classes and sections of our code that were repetitive, but at some point we had accepted that we were not going to take the time to make our code more efficient. However, if we did get the opportunity to start over, we definitely would have taken more time to plan out more efficient methods within the many classes we created, to eliminate any repeat code and the task of hard-coding as well. 



# Catan OOP Game

Introduction
Built a fully functional multiplayer version of Catan from scratch in C++, emphasizing clean architecture and maintainability. Used the Model-View-Controller design pattern to decouple the game logic (Model), user input handling (Controller), and terminal-based UI (View). The game supports loading/saving states, randomized or user-defined boards, and features complex game mechanics like resource trading, road/residence building, and the geese mechanic. Employed C++ features such as smart pointers, enums, and exception handling to ensure stability and scalability.

Architecture
<br>
The Implementation follows the format of the Model View Controller Design pattern. The Model class stores the application's main components and mediates communication between the Board and Player. It stores the data of each Player (an array of 4 players on the stack) as well as the Board (also on the stack). Model is then updated through function calls from the Controller class. The Controller class is responsible for handling user input and control flow, while the View represents the user interface and is responsible for displaying data to the user. It retrieves data from the Model and renders it to the user.

The program runs by first calling the controller class. It uses the built in ctor resulting in all fields except Model and View being set. In this Controller class, there is a general function that outlines the different phases of the game:
Controller::createController()
Controller::beginnningOfGame()
Controller::beginningOfTurn()
Controller::DuringTurn()

In the Controller::general(), the code first calls createController() which deals with all logic for reading in command line arguments and determines whether it loads the board, loads a game, or randomizes a board. After that, setModel is called, which deals with extracting the necessary data for creating a Model and View. It deals with randomising a board/reading in information and placing data accordingly for the Model ctor. All throughout, the program is also checking for invalid input (which uses global variable invalidInput). The functions then return 0 to Controller::general() indicating success or the constant invalidInput to signify ending the program which is then dealt with accordingly by returning the error variable to main. 

From then on, every function call from within Controller::general() returns a state: 0 for regular, eof for end of file, eofNoSave for end of file + save() function has already been called, and gameWon for a player having 10 or more building points.

Ctors
<br>
There are 2 versions of a Model ctor - one is used for loading a game and another for loading a board. When any Model ctor is created, it receives necessary information to create a Board and Players. In the Board ctor, there are also 2 versions. One is used for loading in a game - it calls the other Board ctor (the general one) which creates the Tiles and adds the resources (in body of ctor) and then the first ctor adds the geese accordingly in its own body. The general board ctor also modifies all the tiles and their vertices/edges by setting the adjacency relationships (in body of ctor). It gives each edge and vertex a list of all edges and vertices it’s adjacent to which is set using a public setter function (more on invariants of this part in the design section). These are what gets used to check if the player can place a road or edge. When creating the Board Constructor, the code first creates all the vertices and edges so it has their memory addresses to give to the Tile ctor. In the case of just loading in a board, only the general Board ctor is called, which also creates the Tiles and resources but also deals with the geese (dictated by a boolean which tells the program that it’s not being used to load in a game). Then the Tile ctor gets pointers to the vertices and edges it holds and all other necessary information for its fields. The player also has 2 ctors - one for when a game would be loaded in and one for a fresh game. After model is created, Controller then gives view a pointer to model.

Control Flow of Game
<br>
Then in the general function, the beginning of the game flow starts. From now on, every function call from within Controller::general() returns a state (0 for regular, eof for end of file, eofNoSave for eof + save() function has already been called, or gameWon for a player having 10 or more building points). General() then deals with this accordingly by calling save(), and/or returning eof to main, continuing the game as needed. 
Moving on, if the game is not loaded in, beginningOfGame() is called. This function deals with placing the 2 basements for each Player. Then if the game is loaded in, the function checks if a player has already gained 10 or more points: if they have then the following section is skipped. This consists of beginningOfTurn() and duringTurn(). beginningOfTurn() deals with getting input from the user for the dice type, rolling the dice, and updating player’s information based on the dice rolled. duringTurn() gets commands from the user until next is entered or if a player gained 10 or more building points. 

Winning Game
<br>
Once the game has been won, in Controller::general(), the player is prompted to start a new game or stop. This is the only time where if eof is encountered, the state of the game is not saved. If a player wants to start a new game, the restart() function just randomises a new board and creates a new model and view using the built-in move assignment operator for a unique_ptr. 

Geese
<br>
The geese function in the Controller class performs all of the necessary tasks when a 7 is rolled. All prompts are printed in the Controller class, and when the input is read in from the client, it is passed to smaller methods within the Model class. The model class first loops through the players and returns a vector of all players that have lost half of their resources. This data is printed in the Controller classes geese method. The logic presented in the shuffle.cc file is used, along with an additional class template called “std::uniform_int_distribution<int>”, to randomly select which resources would be lost from the players to make sure that every resource had an equal probability of being removed. The geese is placed on the new tile, and the previous tiles isGeese is set to false, while the new tiles is set to true. Finally, th code generates a list of players the current player could steal from, based on their resourceTotal, their colour, and whether they have residences on the geese tile. The client is then prompted to choose a player to steal from, and the same logic is used to randomly select a resource from the indicated player. 


Trade
<br>
The trade function in the controller class follows a very similar ideology, where the code checks that the trade can be made, and then adds and removes the trade resources from the two players involved in the trade. 

Updating Resources Gained
<br>
If the dice rolled was not a 7, the resources gained for each player is updated by calling Model::diceRolledUpdate which returns a vector of length 4 where each index stores a map of resources and integers representing the resources gained for that player. Then each player is looped through and their resources are printed. In diceRolledUpdate(), for each player, the code gets their occupied tiles. Then for each tile in occupiedTiles, the code calls Board::getResoc() which calls Tile::evalResoc() which then returns a pair of a Resource and an integer representing the amount of resources gained for that tile. These get added to the array of all resources gained (only if amount of resources gained > 0) that will be returned and are also passed to updateResoc map which adds the gained resources for the particular player while also updating resocTotal. evalResoc checks for the park tile (in that case, it returns nothing) and then calls getResidenceAmount for each vertex which just returns the Residence.

Placing a Basement
<br>
There are 2 cases. The first case is at the beginning of the game when players place their 2 basements. Controller::buildDefaultBasements() is called which. It deals with getting user input (including any invalid input where if not eof, the program continues trying to read in from the same player) and determining if the user can place the basement there or not. This is its implementation, it calls Model::placeBasement() which returns true or false. If true is returned it means that the basement was placed and false otherwise. The second case is when placing a basement using the build-res command. in which Controller::buildRes() is called then . It first checks if the player has enough resources to build a basement by calling Model::hasEnoughResoc() which returns true or false by calling Player::hasEnough Resoc on the player whose turn it is. Then Model::placeBasement() is also called. This function then calls Board::placeBasement(), Tiles::placeBasement(), and Vertex::placeBasement(). Starting at Vertex::placeBasement(), this function checks if the vertex the user wants to place a basement on has been found. If that's not the case, then the code just returns; so nothing gets thrown up the call chain. If the code has found the vertex, it does all the necessary checks for that vertex (is it occupied) and other vertices by looping through its adjacent vertices (are they occupied). Then if this function was called by Controller::buildDefaultBasements() (determined through a variable), the code doesn't check the adjacent edges. If it was called by Controller::buildRes() the code checks that the player has an adjacent edge occupied as it loops through adjEdges. If all necessary requirements are passed, the residence and player type is added to the vertex and true is thrown, otherwise false is thrown. In Tiles::placeBasement(), the code catches and throws the boolean that was thrown by the Vertex::placeBasement() function. While the try-catch block could have been omitted, it explicitly shows that there is something being thrown through this function in order to be more careful. In Board::placeBasement(), if the code catches true, it then throws the tile number that the try-catch block was executed from and if its false, it doesn't throw anything and the function call just ends. In Model::placeBasement(), if the code catches the tileNum (int), it adds the buildingPoints by calling a function in player, and then call a function in Model to find all other tiles containing the vertex it placed a basement on and adds them to occupiedTiles in the Player class. The code then returns true. If nothing was caught, the code returns false. Then in buildRes and buildDefaultBasements in Controller, the code outputs the necessary information based on the return statement. 

Placing A Road
<br>
The same logic is applied here as placing a basement. The only difference is that the functions have different names and their rules/functionality are a bit different. For example, no building points are added if a road is placed and Edge::placeRoad() function has different criteria for placing a road. In the placeRoad() function in the Edge class, the code also loops through vertices and edges but it also loops through the vertices of the adjacent edges as well to prevent building a road through a residence of a different player.

Improving a Residence
<br>
The placeNonBasement() function works in a similar manner. The sequence and layout of the function call is the same. The only difference is that in Vertex:placeNonBasement(), after checking all the necessary criteria, if it was met, the code either throws a pair of the Residence type that was improved and true for the residence being improved of the residence that was at the vertex that was not improved and false to show that no new residence was placed. In Tile:placeNonBasement() andBoard::placeNonBasement(), the code rethrows the pair until it reaches Model. Then, Model also computes similarly to the placeBasement function, and returns the pair. In Controller::improveRes, the code then checks for if the player has enough resources first (if the residence type was not Residence::NONE) and then outputs the necessary code. It's done this way so that having the correct number of resources would take priority in terms of outputting the validity of placing residences and roads.

printBoard Function
<br>
The printBoard function in the View class utilises the setw() function from the iomanip library to maintain symmetric padding regardless of the length of the tile’s contents. It also uses several helper functions to print different components of the board, such as the bars, tile labels, edges, and vertices. Since all the tiles are stored in an array, the function iterates through each tile to obtain its associated resource, value, and number to print. This function was part of the View class as printing the board is part of the user interface and displaying the data of the board. 

UML 
<br>
https://lucid.app/lucidchart/7454e148-4251-4686-8a1b-a2f41c28afa9/edit?invitationId=inv_6e2c8d98-7914-475c-af1c-a6075ebb96c4

Design
<br>
Each class is responsible for a particular part of the program. For example, the Controller is responsible for the printing and control flow of the game, the View is for printing the layout of the board, and Model to store all the data of the game. In the Controller class itself, many functions break up the control of the game. For example, beginningOfGame(), beginningOfTurn(), and other functions signify different stages in the game. The controller class calls functions of View (mainly printBoard()) to print the board to the screen and it also calls functions from Model to get necessary information from Board and Player classes and act accordingly. 
The game is also designed with low coupling and high cohesion in mind. Everytime, Controller needs to modify Board or Player, or get information from them, there is a sequence of calls where e.g. Model would call a Board function which would call a Tile function which would call a Component function to modify its own fields and then pass necessary information to upper classes. There are a lot of functions that deal with letting outside classes work with the data of the class without giving them access to their fields (eg updateResocMap() or addBuildingPoints()). All fields in every class are private and can only be accessed through public functions. This route is taken when constructing instances of the objects. For example, when a Model is created, the Model would create a Board and a Player and then the Board would create the 19 Tiles… and so on with Component.
Additionally, each class has its own particular purpose in the game. For example, Model maintains communication between Player and Board and acts as an interface for the classes. Model contains many functions to access Board and Player accordingly and deals with the transfer of communication between the 2 classes which then computes necessary actions as needed by the Controller. View only contains print functions for printing out the contents of the board. Board contains functions to place residences, roads, or to place geese, etc… Controller only contains functions that deal with control flow or commands taken from standard input. 
Additionally, each class stores information specific to their purpose. For example, “turn” is stored in Controller, as Controller is responsible for the flow of the game. Additionally, Tile stores all information that a tile needs - e.g. its tile value, tile number, whether it's a geese or not, and the edges and vertices that make up the tile. 
*While I don’t really like that the Board stores an array of edges and vertices as that should only be stored in Tile, this addition is deemed necessary. Additionally these arrays are not being used to directly access the vertices and edges anywhere in the program. Tiles and vertices are only access through the Tile class in order to maintain encapsulation. These arrays are only used to create the addresses of vertices and edges before the Tiles are constructed in the Board class. The idea is that everything should be created as directly as possible using the MIL in the constructors. To specify, the edges and vertices need to be created before the tiles so that each vertex and edge is able to store the addresses of its adjacent vertices and edges and access them to prevent looping through the entire board.*
There were other designs choices that cut down on runtime. For example, each player stores a vector of numbers that represent tiles that have residences or roads owned by the Player. This way when information is needed from the board for each player, there's no need to search all the tiles. Additionally when adding multiple tiles for a placement of 1 edge or tile, a vector of distinct tiles and edges is used to not have to loop through every tile and check if the residence built was on that tile. Also, there is a maximum of 2 tiles sharing an edge and a maximum of 3 tiles sharing a vertex to reduce runtime - looping terminates if reached this max. 
Moreover, there is a lot of enumerations and global const variables used to get rid of magic numbers in the code. For example the number of tiles is stored in tilesAmount, the number of players is stored in playerAmount, and certain states e.g. EOF or invalid input are represented by a variable as well. Enumerations are also used to group data and improve communication. For example, the 3rd index in the players array in class Model represents the colour Orange (in the enum O = 3) and Residence H had 2 building points (in the enum H = 2). 
Additionally, since a lot of information is given in advance (e.g. number of players or tiles), a majority of the data is created on the stack - e.g. Players, Board, Controller, vertices, edges. This way, the possibility of memory leaks is reduced. 
Furthermore, there are other intentional design choices : adjacent vertices and edges are only added to the first encountered numbered tile in the board and not the ones following it. This prevents adding copies of the relationships for every single vertex and edge in the board since the first tile encountered storing the vertex or edge would have the adjacency lists. Additionally this also helped cut down on runtime, since all the logic would be done at the first tile found. So in the case of adding a valid residence or road, it is known that all other tiles sharing that vertex/edge can only occur in front of that tile, which prevents having to start at the beginning of the board and look for all the tiles sharing thay vertex/edge.

Resilience to Change
	Due to the fact that the Architecture Model-View-Controller pattern is being used to organize the structure of the code, this makes it easy to implement a graphical interface, or show the data in different ways. Within the View class, it is possible to create several decorators to display the data in different forms. For example, there could be a decorator that displays a colour-coded board, or a decorator that visually shows the resource production from a tile.  
Again, since the MVC design pattern is being used, there is a lot of code reusability that can be utilized. One way to do this is by adding more players, and this would not cause a change in the interface. Since the model class has an array of players, there is no need to add any new code to deal with this. 
In terms of the Tile class, more fields could be added to it, to allow for the implementation of extra features and to store more specific data overall. For example, a special tile could be added, such that if a user rolled that number, they would have the ability to perform a special random action, similar to how the “chance” and “community chest” tiles function in Monopoly. This would have made the game a lot more interesting and fun for the users.  
Moreover, many important methods belonging to different classes are public, and this allows for code reusability when implementing new changes. Particularly, many of the public methods perform basic tasks such as modifying and accessing certain fields, and therefore, it would not be difficult to reuse these methods. 
Moreover, a new control flow could be created. By doing so, only the Controller class needs to be modified. Since it is the only class that deals with the current control flow, all of the other classes would remain the same.
Another change to easily implement would be to add more commands to the Controller class. In essence, you would just have to add the command name in the existing while loop and add a method in the Controller class to perform a task related to that particular command. 
Additionally, there are no significant dependencies or links between random methods between classes, which allows one to be able to easily able to modify any method in the program. 
Due to modularization, with a lot of new changes, you would only have to alter one class most of the time, since the classes are loosely coupled. This is the case since the classes only communicate with each other using public functions, and none of the classes are friends.
Furthermore, if you wanted to change the format of the save function, you would just have to alter how the code is added to the file stream that is currently being used within this function. Otherwise, all the necessary functions to get data from the board and the players are the same. 
In terms of adding more residences or resources, it would be quite easy to do so since all you would have to do is alter the enumeration, and most functions dynamically use these enumerations.
Lastly, if you wanted to add a different type of component, it would also be easy to do so, since there is a common interface for a component, which currently extends to the Vertex and Edge classes.

